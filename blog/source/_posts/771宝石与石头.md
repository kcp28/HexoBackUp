---
title: 771宝石与石头
date: 2020-10-02 10:42:07
categories: leetcode题
tags:
- 数组
- 哈希
---

## 题目描述

(难度：简单 题目链接：https://leetcode-cn.com/problems/jewels-and-stones/)

给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。<!--more-->

**示例 1:**

> 输入: J = "aA", S = "aAAbbbb"
> 输出: 3

**示例 2:**

> 输入: J = "z", S = "ZZ"
> 输出: 0

**注意:**

- S 和 J 最多含有50个字母。

-  J 中的字符不重复。

## 思路及代码(c)

本题主要利用哈希的思想。由于该题区分大小写，所以建立了两个数组，长度都是26，用于记录宝石的类型。先遍历J数组，并令记录宝石类型的数组`J[i]-'a'`或`J[i]-'A'`位置的值置为1，表示存在该类型的宝石。遍历完J数组后，遍历S数组，同时检查记录宝石类型的数组在`S[i]-'a'`或`S[i]-'A'`位置上是否为1，若为1则是宝石的数量加一。

```c
int numJewelsInStones(char * J, char * S){
    int sAlph[26],lAlph[26];//记录宝石的类型
    int i;
    int num=0;//石头中是宝石的数量
    for(i=0;i<26;i++){//初始化
        sAlph[i]=0;
        lAlph[i]=0;
    }
    //遍历J
    for(i=0;i<strlen(J);i++){
        if(J[i]>='a'&&J[i]<='z'){//小写字母
            sAlph[J[i]-'a']=1;
        }else{//大写字母
            lAlph[J[i]-'A']=1;
        }
    }
    //遍历S，查找石头中有多少宝石
    for(i=0;i<strlen(S);i++){
        if(S[i]>='a'&&S[i]<='z'){//当前石头是小写
            //检查当前石头是否是宝石
            if(sAlph[S[i]-'a']==1)num++;
        }else{//当前石头是大写
            if(lAlph[S[i]-'A']==1)num++;
        }
    }
    return num;
}
```

