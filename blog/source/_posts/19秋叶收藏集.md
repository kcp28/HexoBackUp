---
title: 19秋叶收藏集
date: 2020-10-01 15:25:05
categories: leetcode题
tags:
- leetcode
- 动态规划
---

## 题目描述

(难度：中等 题目链接：https://leetcode-cn.com/problems/UlBDOe/)

小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。
出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。

<!--more-->

**示例 1：**

> 输入：leaves = "rrryyyrryyyrr"
>
> 输出：2
>
> 解释：调整两次，将中间的两片红叶替换成黄叶，得到 "rrryyyyyyyyrr"
>

**示例 2：**

> 输入：leaves = "ryr"
>
> 输出：0
>
> 解释：已符合要求，不需要额外操作
>

**提示：**

- 3 <= leaves.length <= 10^5

- leaves 中只包含字符 'r' 和字符 'y'

## 思路

(参考自leetcode官方题解：https://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/)

动态规划重点就是要设定状态，找到状态转移方程。

用0、1、2表示叶子的颜色：0表示最前面的那个红色叶子；1表示黄色叶子；2表示后边的红色叶子。

`f[i][j]`表示从`0~i`片叶子，满足使第i片叶子为j这个状态时，需要调整的最小次数。其中，i的取值为`[0,n) `(n为叶子总数)，j的取值范围为`[0,2]`。

- 当`j==0`时,`f[i][0]`表示要把第i片叶子变为红色需要调整的最小次数。当第i片叶子为0时，由题意得，前边`0~i-1`片叶子也必须为0。此时，`f[i][0]`的动态转移方程为：

  ```
  f[i][0]=f[i-1][0]+isYellow(i);//当i片为黄色时isYellow(i)返回1，红色返回0
  ```

- 当`j==1`时，`f[i][1]`表示要把第i片叶子变为黄色需要调整的最小次数。当第i片叶子为1时，由题意得，前边`0~i-1`片叶子可等于0或1。此时，`f[i][1]`的值由`f[i-1][0]`和`f[i-1][1]`中较小的那个确定。动态转移方程为：

  ```
  f[i][1]=min(f[i-1][0],f[i-1][1])+isRed(i);//当i片为红色时isRed(i)返回1，黄色返回0
  ```

- 当`j==2`时，`f[i][2]`表示要把第i片叶子变为红色需要调整的最小次数。当第i片叶子为2时，由题意得，前边`0~i-1`片叶子可等于0或1或2，但第i-1片叶子的取值只能是1或2。此时，`f[i][2]`的值由`f[i-1][1]`和`f[i-1][2]`中较小的那个确定。动态转移方程为：

  ```
  f[i][2]=min(f[i-1][1],f[i-1][2])+isYellow(i);//当i片为黄色时isYellow(i)返回1，红色返回0
  ```

​    当动态转移方程都确定之后，还要关注一些细节。题目规定:"每部分的叶子的数量可以不等，但必须大于1"，我们就需要考虑每个状态是否符合题目的要求。当j==2时，`f[0][2]`表示第0片叶子为第二部分红色时需要调整的次数，这个状态明显不符合题意。同理`f[0][1]、f[1][2]`表示的状态均不符合题意。我们可以把不符合题意的状态值设置为一个极大值（例如 n+1 或整数类型的上限等）。

对于边界，当i=0时，`f[0][j]`的值由`f[0-1][j]`确定，但`f[0-1][j]`的值没有意义，所以规定i=0时为边界。同时，为了符合题意，当i=0时，j只能等于0，所以规定边界为`f[0][0]`:

```
f[0][0]=isYellow(0);
```

## 代码(c)

```c
int minimumOperations(char* leaves){
    int n=strlen(leaves);
    int f[n][3];
    f[0][0]=(leaves[0]=='y');//确定边界
    f[0][1]=f[0][2]=f[1][2]=INT_MAX;//不符合题意的状态的值，设置为极大值
    for(int i=1;i<n;i++){
        int isRed=(leaves[i]=='r');//第i片叶子为红色时，isRed为1；黄色为0
        int isYellow=(leaves[i]=='y');//第i片叶子为黄色时，isYellow为1；红色为0
        //当j==0
        f[i][0]=f[i-1][0]+isYellow;
        //当j==1
        f[i][1]=(f[i-1][0]<=f[i-1][1]?f[i-1][0]:f[i-1][1])+isRed;
        //当j==2
        if(i>=2){//i=0,1时，f[i][2]都不符合要求
            f[i][2]=(f[i-1][1]<=f[i-1][2]?f[i-1][1]:f[i-1][2])+isYellow;
        }
    }
    return f[n-1][2];
}
```



